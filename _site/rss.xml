<?xml version="1.0" encoding="UTF-8"?>
<rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[Greduan's Blog]]></title><description><![CDATA[Greduan's Blog]]></description><link>http://blog.greduan.com</link><generator>metalsmith-feed</generator><lastBuildDate>Sat, 18 Jun 2016 23:03:47 GMT</lastBuildDate><atom:link href="http://blog.greduan.com/rss.xml" rel="self" type="application/rss+xml"/><author><![CDATA[Eduardo Lavaque]]></author><item><title><![CDATA[How to run a Promises array synchronously]]></title><description><![CDATA[<p>Put the following code in a file and run it with Node.js:</p>
<pre><code class="language-javascript">var calls = [];

var promises = [
  new Promise(function (resolve) {
    setTimeout(function () {
      calls.push('first');

      resolve();
    }, 100);
  }),
  new Promise(function (resolve) {
    calls.push('second');

    resolve();
  }),
];

setTimeout(function () {
  console.log(calls);
}, 100);
</code></pre>
<p>Please be aware the following code is bad practice, I'm creating a side-effect
with a Promise, and side-effects like that can be hard to debug.</p>
<p>Why did <code>calls</code> have content?  And why was it <code>['second', 'first']</code> and not the
other way around?  That's because of how Promises behave, they execute as soon
as the JS engine goes over them, not when you call <code>.then()</code> on them, and the
first one runs (approximately) 100ms after the second one because of the
<code>setTimeout</code>.</p>
<p>So then, can we somehow run Promises synchronously?  Even if that sorta defeats
the point of Promises?  Yes you can.</p>
<p>You can game the JS engine a bit.</p>
<p>Try running the following:</p>
<pre><code class="language-javascript">var Promise = require('bluebird');

var calls = [];

var promises = [
  function () {
    return new Promise(function (resolve) {
      setTimeout(function () {
        calls.push('first');

        resolve();
      }, 100);
    });
  },
  function () {
    return new Promise(function (resolve) {
      calls.push('second');

      resolve();
    });
  },
];

Promise
  .each(promises, function (promise) {
    return promise();
  })
  .then(function () {
    console.log(calls);
  });
</code></pre>
<p>The output is <code>['first', 'second']</code>!  How are the Promises running
synchronously?</p>
<p>The answer is simple, first, they are now defined inside function, the
function's contents aren't executed until the function is invoked, which is done
by the <code>Promise.each</code>, and the way <code>Promise.each</code> works is that if you return a
then-able it will wait until the then-able resolves in order to continue with
the next thing in the loop.</p>
<p>And that's it, because we're not executing the function until the previous
function's output's then-able resolves, the Promises are run in order.</p>
<p>It's a simple yet clever trick.  Many thanks to my coworker
<a href="https://twitter.com/pateketrueke">@pateketrueke</a> for figuring this stuff out with me.</p>
]]></description><link>http://blog.greduan.com/2016-06-17-promise-series.html</link><guid isPermaLink="true">http://blog.greduan.com/2016-06-17-promise-series.html</guid><dc:creator><![CDATA[Eduardo Lavaque]]></dc:creator><pubDate>Fri, 17 Jun 2016 00:00:00 GMT</pubDate></item><item><title><![CDATA[File navigation in Vim (my way)]]></title><description><![CDATA[<p>I'm going to talk about a flow I've developed recently, for myself, for
navigating files within Vim.</p>
<p>Note I say Vim in the post title but I use Neovim, I just felt like saying that,
because it makes no real difference to this post's content.</p>
<p>Let's just start with saying that I use <a href="https://github.com/junegunn/fzf">fzf</a> for finding files in a fuzzy
matching manner.  This is incredibly convenient.  You can of course use
<a href="https://github.com/ctrlpvim/ctrlp.vim">CtrlP</a> or whatever you prefer, but I use fzf.</p>
<p>So that's one way I navigate them, another way that, in combination with the
above, is actually quite powerful, is with netrw-like or netrw enhancing
plugins.</p>
<p>Namely <a href="https://github.com/tpope/vim-vinegar">vim-vinegar</a> and <a href="https://github.com/justinmk/vim-dirvish">vim-dirvish</a>.</p>
<p>Why do I use two conflicting-looking plugins?</p>
<p>I use Vinegar because Vinegar provides a map of <code>-</code> to open the current folder
in netrw, or go up one folder if already in netrw. But netrw isn't Dirvish,
don't worry, cause Dirvish hijacks netrw so when you open netrw, Dirvish opens
instead.</p>
<p>Dirvish is what makes this setup cool for me, so if you haven't already, read
its <a href="https://github.com/justinmk/vim-dirvish#readme">README file</a>.</p>
<p>Anyway, I wanted to document that.  I'll also share my related rc config stuff
so that you and I can reproduce this behaviour easily:</p>
<pre><code>Plug 'junegunn/fzf', { 'dir': '~/.fzf', 'do': './install --no-update-rc' }
Plug 'junegunn/fzf.vim'
Plug 'tpope/vim-vinegar'
Plug 'justinmk/vim-dirvish'

&quot; Relative line numbers in a Dirvish buffer
autocmd! FileType dirvish setlocal relativenumber
</code></pre>
<h2>Update 2016-06-14</h2>
<p>Somebody on Twitter actually let me know that you don't need vim-vinegar to have
the usage of the <code>-</code> keybind, vim-dirvish added it to itself now, which is
great.</p>
<p>So you can just have vim-dirvish installed now and that'll work out great. :)</p>
]]></description><link>http://blog.greduan.com/2016-04-09-fnivmw.html</link><guid isPermaLink="true">http://blog.greduan.com/2016-04-09-fnivmw.html</guid><dc:creator><![CDATA[Eduardo Lavaque]]></dc:creator><pubDate>Sat, 09 Apr 2016 00:00:00 GMT</pubDate></item><item><title><![CDATA[Two months of OpenBSD]]></title><description><![CDATA[<p><strong>September 1st: This blog post was originally written back in June 18th, and it
was a draft so I didn't publish it, but it's been here for so long I decided to
publish it.</strong></p>
<p>If you haven't already, read my previous blog post about OpenBSD where I shared
<a href="http://blog.greduan.com/2015-04-19-mstobfi.html">my experience of switching to OpenBSD</a>.</p>
<p>OK, in this blog post I am going to share my experience of using OpenBSD on my
main rig for 2 whole months, and why I switched back to Linux (gasp!).  I am
writing this in Arch Linux which I just installed today, in case you're
wondering.</p>
<p>Let's start off by saying, it has probably been my favorite experience from an
OS.  It is certainly the first OS (after the CRUX distro) that I did not feel
dirty installing or using.  With Arch I always have this itch in the back of my
head which makes me uncomfortable using the OS.</p>
<p>The lack of GNU in my coreutils and ksh being the default shell was a very nice
feeling.</p>
<p>It certainly felt weird to not be using a rolling-release OS, and I never
installed any patches or <code>-current</code> so I probably missed out on a whole
experience.</p>
<p>All I'm saying is, I didn't leave OpenBSD because I didn't like it.  I loved it!
I am leaving OpenBSD because the Node.js support on it is weak.  And I know the
guy maintaining the <code>node</code> package is doing his dangdest, but sadly without
<a href="https://github.com/creationix/nvm"><code>nvm</code></a> or something similar one can't have a good Node.js dev environment,
and <code>nvm</code> depends on the prebuilt binaries Node.js offers, which do not have
BSD versions. :/</p>
<p>For those unaware, when working with Node.js one often has to work with several
versions of Node.  0.10 being stable, 0.12 being the stable but sorta new
Node.js, and io.js being the absolute newest and least stable.  Because you work
with different versions depending on your client or your project, you need to
switch between these versions.  <code>nvm</code> offers a cool feature where you can do
<code>nvm use 0.10</code> and boom, your path now has Node 0.10 in the PATH instead of 0.12
or whatever.</p>
<p>The lack of a tool like <code>nvm</code> is incredibly inconvenient, and that is why I'm
switching back to Linux.  So it's nothing personal, it's just Node.js is my job
and I need <code>nvm</code>.</p>
<!--
> TODO: Add link to blog post I haven't written yet. :P
<p>Back to OpenBSD, I have written a blog post that will surely be of interest to
any Linux person thinking about switching or that are in the process of
switching.  It covers some of the questions that I myself had when switching.
--&gt;</p>
<p>In the future I will definitely be switching back to OpenBSD if the situation
with Node.js improves, get on it devs! :)</p>
]]></description><link>http://blog.greduan.com/2015-06-18-tmoo.html</link><guid isPermaLink="true">http://blog.greduan.com/2015-06-18-tmoo.html</guid><dc:creator><![CDATA[Eduardo Lavaque]]></dc:creator><pubDate>Thu, 18 Jun 2015 00:00:00 GMT</pubDate></item><item><title><![CDATA[Indentation and hooks in Emacs]]></title><description><![CDATA[<p>I've been using Emacs on and off for around half a year, maybe a little bit
more, more recently I've been using it daily because I've been using Org-mode
more and I've been editing code with it.</p>
<p>Something that has always bothered me about Emacs is how dang difficult it is to
manage indentation configs and stuff like that.  I've never been able to have a
nice clean way to have a per-filetype based indentation config.</p>
<p>This is coming from the perspective of an adept Vim user, as it isn't actually
<em>that</em> hard in Emacs, it's just tedious, while in Vim it's <a href="http://stackoverflow.com/a/1562645">just one line</a>.</p>
<p>For a while I was just using the <a href="http://editorconfig.org/">editorconfig</a> Emacs plugin, but it doesn't
work right, since it only checks the config for a file <em>once</em>, and that is when
the file is opened.  If the <code>.editorconfig</code> file changes you need to close/open
the file or close Emacs and open the file again.</p>
<p>BTW if you don't use editorconfig in your projects, this is a great chance to
start now.  It only makes sense to use it.</p>
<p>After a bit I started playing around with hooks.</p>
<p>Now for me the problem with hooks is that they're a bit verbose.  That's not
really a problem, it's just me not used to how verbose Lisp can get sometimes.</p>
<!--
Another problem is that sometimes a mode doesn't offer a hook for some reason.
Those can be a bit annoying to deal with, also I had trouble finding what the
name of the hook is.
-->
<p>I am here to help you out with Emacs hooks.</p>
<h2>Searching for mode hooks</h2>
<p>This is quite simple, if you're not familiar with Emacs' built-in help system,
you really should look into it (<code>C-h C-h</code>).</p>
<p>Do <code>C-h v</code> to look for a variable, then start typing the name of the mode, let's
say <code>shell-script</code> and then press tab, or <code>?</code> works as well.  Probably one of
the last results you'll get is <code>shell-script-mode-hook</code>.  Try it for other modes
you're interested in, you'll probably be able to find them this way.</p>
<p>Now there are some caveats, apparently not all hooks are made equal.  For
example, <code>javascript-mode-hook</code> doesn't do anything, but <code>js-mode-hook</code> does,
even though the major mode is called <code>javascript-mode</code>.</p>
<h2>My indentation strategy</h2>
<p>Now it took me a bit, but I deviced a system that works pretty nicely and is not
very verbose for my tastes, it is a bit tedious though if you don't have
<a href="https://github.com/abo-abo/lispy">Lispy</a> or Paredit.</p>
<p>Anyway, the strategy I have is simple.  First I define a default indentation
setup:</p>
<pre><code class="language-elisp">;; default
(setq-default tab-width 4)
(setq-default tab-stop-list (number-sequence 4 100 4))
(setq-default indent-tabs-mode 1)
</code></pre>
<p>You can find out what <code>tab-width</code>, <code>tab-stop-list</code> and <code>indent-tabs-mode</code> do
with <code>C-h v</code>, and about what <code>number-sequence</code> does with <code>C-h f</code>.</p>
<p>Those are some defaults that I want to have on every file for which I haven't
defined something else.</p>
<p>Next I define a utility function:</p>
<pre><code class="language-elisp">(defun my-tabs-stuff (tabs length)
  (setq indent-tabs-mode tabs)
  (setq tab-width length)
  (setq tab-stop-list (number-sequence length 100 length)))
</code></pre>
<p>What this function does is it just tells the buffer in which it is being run if
we should use real tabs or fake/space tabs (<code>indent-tabs-mode</code>), then it goes on
to tell it how long a real tab should look (<code>tab-width</code>) and what Emacs should
treat as a tab when dealing with spaces (<code>tab-stop-list</code>).  That's all our
function does.</p>
<p>Then we go on to define hook functions, these are the functions we are going to
refer to as the function that gets called when the hook is triggered.</p>
<pre><code class="language-elisp">(defun my-emacs-lisp-hook ()
  (my-tabs-stuff nil 2))
(defun my-shell-script-hook ()
  (my-tabs-stuff 1 4))
(defun my-js-hook ()
  (my-tabs-stuff 1 2))
</code></pre>
<p>So we are just defining one function per mode, which in my case only call one
function each, the function being <code>my-tabs-stuff</code> and passing it the arguments
for what I want as indentation settings in that mode.</p>
<p>Now all that's left is to add these functions to the hooks:</p>
<pre><code class="language-elisp">(add-hook 'emacs-lisp-mode-hook 'my-emacs-lisp-hook)
(add-hook 'shell-script-mode-hook 'my-shell-script-hook)
(add-hook 'js-mode-hook 'my-js-hook)
;(setq js2-mode-hook js-mode-hook)
</code></pre>
<p>Note the last one, you can basically alias one mode's hooks to another's by
using something like what you see in the last line.</p>
<p>Hopefully that helps you out, I've wasted too much time with Emacs figuring this
out, or not figuring it out and suffering the consequences.  So hopefully this
saves you some time. :)</p>
]]></description><link>http://blog.greduan.com/2015-04-29-iahie.html</link><guid isPermaLink="true">http://blog.greduan.com/2015-04-29-iahie.html</guid><dc:creator><![CDATA[Eduardo Lavaque]]></dc:creator><pubDate>Fri, 29 May 2015 00:00:00 GMT</pubDate></item><item><title><![CDATA[Experience upgrading OpenBSD to 5.7]]></title><description><![CDATA[<p>In short, it was way way way way simpler than I expected it to be.  It took less
than 10 mins to update OpenBSD from 5.6 to 5.7.  And then another half an hour
to update all my packages with <code># pkg_add -u</code>.</p>
<p>The reason I was scared is because I am unfamiliar with this sort of upgrade
procedure, I am used to rolling distros where to update you just run one command
every once in a while and you're up-to-date.  I never used Debian or Ubuntu
extensively so I didn't get to experience freeze periods, OS version numbers
etc.</p>
<p>I mean there's not much more to say about that.  Just so that it's not a really
short post I'll lay out the steps I took:</p>
<ul>
<li>Downloaded the <code>install57.fs</code></li>
<li><code>dd if=install57.fs of=/dev/sd0c bs=4M</code> (<code>of=</code> may vary for you)</li>
<li>Booted into USB</li>
<li>Chose <code>(U)pgrade</code> instead of <code>(I)nstall</code> or <code>(A)uto Install</code></li>
<li>Went through procedure</li>
<li>Rebooted</li>
<li>Read mail (just reports)</li>
<li><code># sysmerge</code></li>
<li><code># pkg_add -u</code></li>
</ul>
<p>And that was it.  It was way simpler than I expected.</p>
<p>I will be upgrading to -current soon enough so I can write about the experience,
also I need the latest <code>sort</code> to have the <code>nvm</code> bug fixed.</p>
<p>EDIT:</p>
<p>Today is May 2nd.  I just realised there is an
<a href="http://www.openbsd.org/faq/upgrade57.html">upgrade guide for 5.6 to 5.7</a>.  I just read that today and I ran the steps,
I missed this part of the upgrade earlier.  Oops.</p>
]]></description><link>http://blog.greduan.com/2015-04-30-euot57.html</link><guid isPermaLink="true">http://blog.greduan.com/2015-04-30-euot57.html</guid><dc:creator><![CDATA[Eduardo Lavaque]]></dc:creator><pubDate>Thu, 30 Apr 2015 00:00:00 GMT</pubDate></item><item><title><![CDATA[My switch to OpenBSD, first impressions]]></title><description><![CDATA[<p>So I switched to OpenBSD, and this blog post is here to talk about my first
impressions.  This probably won't be my last blog post on the subject.</p>
<p>So that you can understand how I use my distros, &quot;ricer&quot; is usually a term used
to refer to people that change the look of their setup to make it look very
attractive, outside of the defaults of whatever environment they have.  Take a
look at <a href="http://www.reddit.com/r/unixporn">/r/unixporn</a> for many good examples of ricing.</p>
<p>An under-the-bonnet ricer means the ricer only looks to improve the workflow or
the commands and stuff they have available to them, not the looks.  I am an
under-the-bonnet ricer to the core.</p>
<p>Because of my nature I've had to reinstall Arch 3 times because I broke it and
have been using CRUX for a while, cause that's a fun distro to play with.</p>
<p>OK, on with BSD.</p>
<h2>Why?</h2>
<p>Why OpenBSD?  Why not FreeBSD or NetBSD or DragonflyBSD or any other BSD?  Why
BSD in the first place?</p>
<p>I've been a Linux user for several years, and more recently I've been getting
into being all POSIX-compliant and stuff and GNU's coreutils have been grinding
on my nerves with that stuff.</p>
<p>So even though Linux is awesome, and compiling it is fun, the OS on top of it I
don't like, so I wanted to switch to something better, that something was BSD.</p>
<p><em>Sidenote: Why does the GNU <code>sort</code> command have an <code>-R</code> flag which <em>randomises</em>
the result?  You can't sort something into being random.  That's an oxymoron
(with a particular choice of definitions).</em></p>
<p>Now, why OpenBSD instead of another BSD?  First of all because my friends at
<a href="http://nixers.net/">Nixers.net</a> prefer OpenBSD (those that use a BSD).  It's good to switch to a
system where you know several people that know it.  Makes the switch much more
fun.</p>
<p>Secondly, in December I did try to switch to FreeBSD.  It was a chance I had to
switch, but I had trouble getting X to work and at that point I really needed a
working OS.  This time I didn't want to deal with the X stuff so I just went
ahead and installed OpenBSD which I had heard had excellent X support out of the
box, and holy crap it does.</p>
<p>And thirdly because of the security orientation that the whole project has.
That is a really attractive feature for me.</p>
<h2>First impressions</h2>
<p>Short version: I'm lovin it.</p>
<p>Keep reading for the long version.</p>
<h3>The install</h3>
<p>Getting the USB stick ready was unique.  I downloaded the <code>install56.iso</code> but
that didn't work when I <code>dd</code>'d it into the USB stick.  So then I read the
<code>INSTALL.amd64</code> file and it uses the <code>.fs</code> file for the USB stick, not the
<code>.iso</code> file, so I downloaded that and <code>dd</code>'d it and it worked.  So that was new.</p>
<p>The install was certainly &quot;weird&quot; for me, coming from more manual Linux distros
where I format the harddrives, mount the partitions, write the <code>fstab</code>, etc. all
manually.  It was pleasant though, somehow I don't feel dirty with a clean
install of OpenBSD as I do with a clean install of any Linux.  Probably the lack
of GNU.  lol</p>
<p>But yeah, I was expecting a slightly more graphical install, since I already
experienced the FreeBSD install, but I'm fine with text prompts.  It's still
simple enough.</p>
<h3>X and hardware support</h3>
<p>The X support was incredible, simply incredible.  I enabled xdm to start with
but quickly disabled it cause I've my own <code>.xinitrc</code> file.  Simply put, if I
don't mention it it's because it worked perfectly.</p>
<p>The only thing that isn't supported is my wifi card.  A dreaded BCM4315.  That
would have been a deal breaker some months ago but now I have an extra long
ethernet cable so it's fine.  This is a laptop though so I need to buy that wifi
dongle...</p>
<p>I am having a bit of trouble with the lid though.  Closing it suspends, which is
fine but then when I open it it's all black.  I pressed butons and stuff and it
didn't turn on again so I'm guessing for some reason my monitor doesn't wake up.
Dunno what's up with that.</p>
<p><em>Sidenote: I've a Dell Vostro 1500 from 2007, with an Intel Core 2 Duo 2.0GHz.</em></p>
<h3>Ports/packages system</h3>
<p>The ports/packages system is something I really like in OpenBSD.  Kinda sad CVS
is still used over Git for the ports, but that ain't gonna stop me from liking
it.  Seriously though y u no Git?</p>
<p>I like how it's decentralised.  A ton of mirrors counts as decentralised for me.
lol</p>
<p>I like how the <code>$PKG_PATH</code> variable works.  I'd be fine with this setup if it
was in some Linux distro.</p>
<p>The <code>pkg_add</code> command works very well as well.  It lets me know of the all the
stuff it's installing, and when it installs dependencies it lets me know what
package requires that dependency.  Makes it easy to tell what piece of software
is installing a ton of dependencies you don't want.  :P</p>
<h3>Being productive again</h3>
<p>First of all, thank you to <a href="http://www.bsdnow.tv/">BSD Now</a> and their tutorials, especially this
one: http://www.bsdnow.tv/tutorials/the-desktop-obsd</p>
<p>As a Node.js dev it can be a little hard to get started if you're used to using
<a href="https://github.com/creationix/nvm"><code>nvm</code></a> because of a little bug which I <a href="https://github.com/creationix/nvm/issues/733">already reported</a>.  By the time
you read this it'll already be fixed most probably.</p>
<p>Though Node v0.10 is included in the packages so I can still work, just not with
the latest and greatest.  I expect that to get updated to v0.11 or v0.12 in
OpenBSD v5.7 though.</p>
<p>Other than that, everything has been very smooth so far.  Some software I like
isn't in the packages but I can compile that myself so there's no issue, and it
may even be in the next release so I'm not too worried.</p>
<p>The first day I installed OpenBSD in the evening.  The next day I spent some
time figuring out how stuff worked, basics here and there etc. Getting up to a
working productive state again.  The next day I was completely productive again.
So the downtime was really just the evening while I was installing it and
figuring out basics.</p>
<p>I'd say that from the moment you plug in the USB to when you get back to work
again is like less than half an hour, honestly.</p>
<h2>Final verdict</h2>
<p>If you're considering switching to OpenBSD, totally go for it.  There is nothing
stopping you but yourself, like seriously.</p>
<p>However, definitely to make sure your hardware is supported.  I spent an hour
trying to figure out why the wifi didn't work because I assumed it worked like
in Linux.</p>
]]></description><link>http://blog.greduan.com/2015-04-19-mstobfi.html</link><guid isPermaLink="true">http://blog.greduan.com/2015-04-19-mstobfi.html</guid><dc:creator><![CDATA[Eduardo Lavaque]]></dc:creator><pubDate>Sun, 19 Apr 2015 00:00:00 GMT</pubDate></item><item><title><![CDATA[December 2014 to April 2015]]></title><description><![CDATA[<p>So first of all, I'm sorry that I haven't written any blog posts in the last few
months.  I don't need to apologize, but I feel like doing it.  If you felt you
deserved an apology, I don't see why but I already apologized, so there.</p>
<p>OK so I'm just gonna give you a quick update of what's happened in these months.</p>
<p>Baiscally, in December I started a move which didn't end until the 26th of
December or something like that.  During that time I had no internet, why?
Cause I had messed up my Arch Linux install, but I didn't have time to
reinstall, so yeah I was stuck without internet or a laptop for almost a month.</p>
<p>Then the first of January of 2015 or something like that I got internet access.
I spent one week debating whether I should install Arch again (cause I was tired
of it) or if I should go with something new.  I wanted to install *BSD but I had
trouble so in the end I went with the <a href="https://crux.nu">CRUX</a> Linux distro.</p>
<p>So I've been using CRUX for 4 months, until yesterday when I installed OpenBSD.</p>
<p>Today I've been having fun discovering OpenBSD.  I'll soon have a blog post
about my experience with OpenBSD.</p>
]]></description><link>http://blog.greduan.com/2015-04-18-d2ta2.html</link><guid isPermaLink="true">http://blog.greduan.com/2015-04-18-d2ta2.html</guid><dc:creator><![CDATA[Eduardo Lavaque]]></dc:creator><pubDate>Sat, 18 Apr 2015 00:00:00 GMT</pubDate></item><item><title><![CDATA[Respect, for respect is acknowledgement, and acknowledgement is a right]]></title><description><![CDATA[<p>I've been thinking, and I think you should respect everyone.  No matter the
circumstances, who the person is or what they've done.</p>
<p>It doesn't need to be respect for his actions, circumstances or for what he/she
has.</p>
<p>It should be respect for the fact that he/she is a human being.</p>
<p>Acknowledgement is important.  When somebody says something they say it
expecting an acknowledgement of the fact that their communication was
understood.</p>
<p>When somebody does something they do it with an expectancy of somebody they care
for or look up to to acknowledge the fact that they did that.  Think the kid who
cleans his room without anyone telling him, he wanted an acknowledgement,
whether that acknowledgement is candy, dessert, or simply gratitude for the fact
that he cleaned his room.</p>
<p>When a teen is being rebellious, he is doing it because previously he did not
get an acknowledgement for who he is, and is expecting, knowingly or
unknowingly, an acknowledgement for who he is.</p>
<p>So do try to acknowledge everyone for who they are.  You don't have to agree,
but you do need to acknowledge, for that is a human right.  (In my humble
opinion.)</p>
]]></description><link>http://blog.greduan.com/2014-12-08-rfriaaaiar.html</link><guid isPermaLink="true">http://blog.greduan.com/2014-12-08-rfriaaaiar.html</guid><dc:creator><![CDATA[Eduardo Lavaque]]></dc:creator><pubDate>Mon, 08 Dec 2014 00:00:00 GMT</pubDate></item><item><title><![CDATA[Figuring out when you installed Arch Linux]]></title><description><![CDATA[<p>I just figured out a cool trick to check when you installed your current Arch
Linux install.</p>
<p>All you have to do is check the logs for pacman which can be found at
<code>/var/log/pacman.log</code>.  Go to the top of the file and look at the date.</p>
<p>Looks like my current install was installed at <code>2014-04-16 15:48</code>.  Longest
running install yet.</p>
<p>Of course this trick depends on the fact that the logs still exist.  If you
cleared those logs then you can't really use this trick.  Although IMO this is
one log you shouldn't delete, considering how valuable its data could be.</p>
]]></description><link>http://blog.greduan.com/2014-12-07-fowyial.html</link><guid isPermaLink="true">http://blog.greduan.com/2014-12-07-fowyial.html</guid><dc:creator><![CDATA[Eduardo Lavaque]]></dc:creator><pubDate>Sun, 07 Dec 2014 00:00:00 GMT</pubDate></item><item><title><![CDATA[Minimal amount of fonts in Arch Linux]]></title><description><![CDATA[<p>Thought I'd document this here.</p>
<p>Some weeks ago I decided I'd find the smallest font packages I could find but
that would still cover the biggest amount of Unicode.</p>
<p>After <a href="https://www.reddit.com/r/archlinux/comments/2l2cr7/what_fonts_do_you_install_for_most_coverage_with/">consulting with Reddit</a> I came up with the following list:</p>
<ul>
<li><code>ttf-dejavu</code> because some programs just need it and it's a pretty global
&quot;default&quot; font in open source.</li>
<li><code>ttf-liberation</code> an extremely good looking alternative to some MS fonts.
Excellent for default <code>serif</code>, <code>sans-serif</code> and <code>monospace</code> fonts.</li>
<li><code>adobe-source-han-sans-otc-fonts</code> for full CJK support.</li>
<li><code>ttf-noto-nockj</code> for big coverage of Unicode that isn't CJK.</li>
</ul>
<p>Just thought I should share that, considering some other people may be looking
for the same thing some time in the future. :)</p>
]]></description><link>http://blog.greduan.com/2014-11-21-maofial.html</link><guid isPermaLink="true">http://blog.greduan.com/2014-11-21-maofial.html</guid><dc:creator><![CDATA[Eduardo Lavaque]]></dc:creator><pubDate>Fri, 21 Nov 2014 00:00:00 GMT</pubDate></item><item><title><![CDATA[Get it together Linux users/devs!]]></title><description><![CDATA[<p>This is a rant for Linux users.  Take it as an (angry) man letting people know
his opinions.</p>
<p>First let's start with unity.  (GNU/)Linux users are either united or they're
not.  The attitude in this community is that if you don't like something about
the distro you're using just go ahead and make a new one.  Yeah thanks for the
advice.</p>
<p>You don't like something about the WM you're using?  Make a new one.</p>
<p>And I'm not particularly bothered by the &quot;put it up or make it up&quot; attitude,
that's completely fine.  What bothers me is how separated the WHOLE community is.</p>
<p>There are thousands of distros, all with their own spin on stuff.  Most, if not
all of them feel some kind of elitism for the distro they use.</p>
<p>Arch Linux users, their distro is incredibly awesome.  In my years with it (a
couple) I haven't seen a single political debate over whether one approach to
something should be used over another (i.e. Systemd vs. Busybox or something).
I mean of course users argue, that's always gonna happen because Linux seems to
be infested with angry people all over the place.  But for a team to be arguing
about what direction to go (i.e. Debian) I find extremely ridiculous.</p>
<p>OK so thousands of distros.  Hundreds of window managers, floating, tiling,
hybrids, dynamic, tiling with a twist, tags, workspaces, gravities, mouse or not,
for christ's sake give it a rest!</p>
<p>This situation where it's everybody against everybody is the exact reason why
stuff like OS X is more attractive to users.  TBH it's more attractive to me, the
only reason I don't use it, although I have been tempted countless times, is
because I have a strong resolution to not buy into a commercialism mentality
which is exactly what Apple has.  New product comes out GO BUY IT!</p>
<p>And in all their super nice hardware and commercialist attitude, they got one
thing right, although not exactly in the best way.  What they got right was that
they made it very easy for developers, develop for the latest version or your
software will go unused.  They do it through planned obsolescency, but Arch Linux
could very well do it just because all the people that use it will only use the
latest of the stuff.</p>
<p>They got another thing right.  There is no divide in the developers.  there is
no debate whether to use Qt or GTK+.  Everybody has only one option.  And I'm not
saying the debate is bad, but the sheer amount of time that we spend in these
debates is just ridiculous.  I'll settle it for you.  GTK+ can use C OR C++, so
it's better in that sense.  Qt is limited to C++ BUT it's got way better
cross-platform support.  There, that's what the argument should boil down to.</p>
<p>In the end I'm sure somebody will be like &quot;oh if it's so easy why don't you do
it?&quot; or &quot;just do the software you want then!&quot;.</p>
<p>That's not my point.  My point is STOP BEING SO ANGRY AT EACH OTHER!</p>
<p>Windows devs get one choice, a really shitty one but it's one.  OS X devs get
one choice, perhaps great or perhaps shitty, I dunno, but it's only one choice.
Linux devs get hundreds, if not thousands of distros to choose from.  They need
to package in who knows how many formats.  They may need to develop in I dunno
how many frameworks for shit to work right.</p>
<p>Linux is sorta Lisp all over again.  Cool great, you convinced me, I wanna use
Linux, where should I start?  Well you've got all of these distros to choose
from.  At least with Lisp the argument is easier.  OK I wanna do Lisp, which
one should I start with?  Well depends on your program, and if you don't like
one you can just install another.  With Linux you gotta re-install the entire OS
to change it.</p>
<p>Point is, stop fighting.  Figure out a distro you like, use it, be nice to each
other, don't give somebody shit cause they're newbs or they don't know how to use
the CLI or when they don't use the distro YOU like.  Let me remind you, we want
more casual users.  The way we're going we may never have a lot of casual users
like OS X or Windows.</p>
<p>I dunno if I got my point across, but at least I said it so now I feel better.
Just be nicer.  I don't care what you do or how much time you have to waste for
it, just be nicer and more united.  Please.</p>
<p>That is all.</p>
<p>P.S.: The post title is a play on words, get it?</p>
]]></description><link>http://blog.greduan.com/2014-10-05-gitlud.html</link><guid isPermaLink="true">http://blog.greduan.com/2014-10-05-gitlud.html</guid><dc:creator><![CDATA[Eduardo Lavaque]]></dc:creator><pubDate>Sun, 05 Oct 2014 00:00:00 GMT</pubDate></item><item><title><![CDATA[The bleeding terminal background inside Vim + Tmux problem]]></title><description><![CDATA[<p>I need to document this as a reminder for myself and as a saviour blog post to
any person out there in the internet that uses Vim and Tmux.</p>
<p>Read the following blog post.  That is all I'm going to say.</p>
<p><a href="http://sunaku.github.io/vim-256color-bce.html">http://sunaku.github.io/vim-256color-bce.html</a></p>
<p>Solved a problem I've had for years in Vim.  Thank you random internet person.</p>
<p>Hopefully this helps you as well, random internet person.</p>
<p>EDIT:</p>
<p>Thought I should probably post the solution as well:</p>
<pre><code>if &amp;term =~ '256color'
    &quot; disable Background Color Erase (BCE) so that color schemes
    &quot; render properly when inside 256-color tmux and GNU screen.
    &quot; see also http://sunaku.github.io/vim-256color-bce.html
    set t_ut=
endif&quot;
</code></pre>
]]></description><link>http://blog.greduan.com/2014-09-10-tbtbivtp.html</link><guid isPermaLink="true">http://blog.greduan.com/2014-09-10-tbtbivtp.html</guid><dc:creator><![CDATA[Eduardo Lavaque]]></dc:creator><pubDate>Wed, 10 Sep 2014 00:00:00 GMT</pubDate></item><item><title><![CDATA[Getting used to software updates]]></title><description><![CDATA[<p>I noticed that some years ago I used to seriously look forward to every update
that any software I was using got.  Like I'd read all the changelogs and I'd be
constantly checking to make sure there wasn't an update to some piece of
software that didn't update itself.</p>
<p>That's also a reason I got into Arch in the first place I think, besides the
minimalism and how I like to build my environment from the ground up.  The
reason being that it has a rolling release model, so all of my software is as
up-to-date as it can be.  Almost, I mean it doesn't go into betas, just into
every &quot;stable&quot; release according to the piece of software.</p>
<p>I think using Linux, specifically Arch Linux, for several years now has
desensitised me to software updates.  Where now I don't look at <em>every</em> update,
instead I look at major updates, updates to the browser, to my text editors,
etc.  Stuff of which you have to be aware because a lot has changed since you
last used it, those kind of changes.</p>
<p>Just thought I would document that I guess, there's not more to this blog post.</p>
]]></description><link>http://blog.greduan.com/2014-09-10-gutsu.html</link><guid isPermaLink="true">http://blog.greduan.com/2014-09-10-gutsu.html</guid><dc:creator><![CDATA[Eduardo Lavaque]]></dc:creator><pubDate>Wed, 10 Sep 2014 00:00:00 GMT</pubDate></item><item><title><![CDATA[Barebones file navigation in Vim]]></title><description><![CDATA[<p>This post is mainly a rip-off of this talk that happened on a Vim London meetup
titled &quot;Bare Bones Navigation, by Kris Jenkins&quot;: <a href="http://vimeo.com/65250028">http://vimeo.com/65250028</a></p>
<p>You can find the slides here: <a href="https://github.com/krisajenkins/bare-bones-vim">https://github.com/krisajenkins/bare-bones-vim</a></p>
<p>He ends the talk with a slide that has the following:</p>
<pre><code class="language-vim">&quot; :find
set path=**
set suffixesadd=.java,.py

&quot; :find gets better more
set nocompatible
set wildmode=full
set wildmenu
set wildignore=*.class,*.pyc

&quot; :ls &amp; :&lt;number&gt;b

&quot; :Explore
&quot; :e scp://host/some/where/file.txt
</code></pre>
<p>So I'll just quickly explain those.  This post is mainly for reference for
myself but I still hope it helps you. :)</p>
<p>Also I've challenged myself to use only these built-in commands for a while
instead of some fancy FZF or Unite.vim or anything of the sort.</p>
<p>Let's start with <code>:find</code>.  This command just finds whatever filename you give
it, no auto-completion just give it a filename and it'll find it.  It needs for
<code>path</code> to be set to <code>**</code> for it to just find any file in the current directory.</p>
<p>The definition of <code>path</code> can get very detailed and complex, so go ahead and go
nuts on your definition.  It can also be comma separted, in case you have
specific paths you like.</p>
<p><code>suffixesadd</code> is for <code>:find</code>, it allows you to skip the file extension and allow
<code>:find</code> to still find the right files.  Set it up so you can save on some
typing.  Comma separated.</p>
<p><code>nocompatible</code> don't need to explain this one, if you're using Vim just use it.</p>
<p><code>wildmode</code> that sets up the kind of auto-completion that Vim has for the <code>:</code>.
While he sets it to <code>full</code> I always set it to <code>list:longest</code>, this is
preference though.</p>
<p><code>wildmenu</code> from what I understand makes it so that the auto-completion isn't all
on one line, so that it uses several lines to show the auto-completion.</p>
<p><code>wildignore</code> is to define files to ignore.  Set it to the files you mostly never
want to edit because only the language uses them, not the programmer.</p>
<p>Then he talks about switching buffers with <code>:ls</code> and <code>:b[uffer]</code>.  Use <code>:ls</code> to
list your buffers and use <code>:b[uffer]</code> to switch to a buffer by buffer number.
While he uses the buffer number before the <code>b</code>, you can also use it afterwards.</p>
<p>Then it's <code>:Ex[plore]</code> (which includes <code>:Sex[plore]</code> and <code>:Vex[plore]</code>) and
<code>:e[dit]</code>.  The <code>:{E,Ve,Se}x[plore]</code> commands open up the built-in netrw file
explorer which is a built-in plugin, which means it is not included if you use
<code>vim -u NONE</code> in order to not load any config or plugins.</p>
<p>VimCasts has a blog post about this that I suggest reading so you get familiar
with this plugin and how to use it:
<a href="http://vimcasts.org/blog/2013/01/oil-and-vinegar-split-windows-and-project-drawer/">http://vimcasts.org/blog/2013/01/oil-and-vinegar-split-windows-and-project-drawer/</a></p>
<p>And finally <code>:e[dit]</code> is a built-in Vim command and all that there is to it is
to give it the full path of the file you want to edit.  The path you give it is
relative to the current directory.</p>
<p>That is all on that subject.  While I'm on it though, I would suggest that if
you are in a setup where you can have a couple of plugins, I really suggest
you install the following plugins by Tim Pope:</p>
<ul>
<li><a href="https://github.com/tpope/vim-sensible">https://github.com/tpope/vim-sensible</a></li>
<li><a href="https://github.com/tpope/vim-vinegar">https://github.com/tpope/vim-vinegar</a></li>
</ul>
<p>That is all, hope this helps.  :)</p>
]]></description><link>http://blog.greduan.com/2014-08-24-bfniv.html</link><guid isPermaLink="true">http://blog.greduan.com/2014-08-24-bfniv.html</guid><dc:creator><![CDATA[Eduardo Lavaque]]></dc:creator><pubDate>Sun, 24 Aug 2014 00:00:00 GMT</pubDate></item><item><title><![CDATA[Navigating in the dark]]></title><description><![CDATA[<p>Just thought I'd quickly write a couple of tips to see in the dark, besides
having good eyes but those are not required.</p>
<p>Right, so I mentioned this to my friend <a href="http://raamdev.com/">Raam Dev</a> and he answered
with the best explanation I could hope for:</p>
<blockquote>
<p>Yeah, I can navigate in the dark really well too, but I think vision and
time-to-night-vision plays less of a role than simply using all of your senses
and being good at making accurate judgment calls about where things are, where
they might be, and then using the way the limited light bounces off objects to
get a better feel for the world around you and then using all of that
information to build a mental image of the world you're navigating. When I
wake up in the middle of the night to use the restroom, which requires walking
down a short hallway outside the bedroom, I <em>always</em> walk with my eyes
<em>closed</em>. I find that walking in the dark with my eyes closed is easier than
walking with my eyes open, because then my brain does all the visualization
and my eyes, which may see reflections or other objects, don't fool my mind
into second-guessing itself.</p>
</blockquote>
<p>And:</p>
<blockquote>
<p>Of course, while walking with my eyes closed, I do use my hands as &quot;sensors&quot;,
to feel walls, the moldings on the walls, the doors, the door handles, the
corners of walls, etc. All of that builds a mental image in my mind that I use
to navigate.</p>
</blockquote>
<p>(Yes I asked for his permission, in case you were wondering.)</p>
<p>So basically, seeing in the night is not all about if you can &quot;see&quot; in the
darkness, although if you can that's cool.  It's mostly about making the most of
the minimal input that you have, mostly visual, because with the rest of the
senses the input is certainly not minimal.</p>
<p>But yeah, for example if I have the chance, before navigating a dark room I try
to turn on a light for a couple of seconds in order to get a very clear mental
image of where all the stuff in the room is.  After that it's just about moving
through that physical space while continually updating your mental image,
essentially.</p>
<p>Ever tried closing your eyes and guessing how many steps it would take to be
from one end of the room to the next or ever tried navigating the house with
your eyes closed?  It's sorta like that.</p>
<p>Remember that you are trying to &quot;see&quot; in an environment where you don't have
enough light to see, so with the small inputs you have, just draw a mental image
of your environment.</p>
<p>Of course it's recommendable to go slowly, so that if you miscalculate something
it doesn't hurt, although with experience this'll start happening less and less.</p>
<p>Just thought I'd share that, hope this helps. :)</p>
]]></description><link>http://blog.greduan.com/2014-08-21-nitd.html</link><guid isPermaLink="true">http://blog.greduan.com/2014-08-21-nitd.html</guid><dc:creator><![CDATA[Eduardo Lavaque]]></dc:creator><pubDate>Thu, 21 Aug 2014 00:00:00 GMT</pubDate></item><item><title><![CDATA[Knowing something but not registering it]]></title><description><![CDATA[<p>Ever have that moment when you realize something that you already knew?</p>
<p>I know it sounds kinda dumb, but it is not that rare for me to realize something
that I had realized before, just never really thought about.</p>
<p>Like I remember one day I watched some Hatsune Miku concert, just one song, and
I realized there was a hologram, and I was like &quot;cool, they've got a hologram&quot;.</p>
<p>Some months later I watched it again and I was like &quot;holy shit holograms!
Technology has gotten to that point!&quot;.</p>
<p>Just an example.</p>
<p>Another one would be how I made an entire CLI app just to download a Gist's
files and put them in the current directory.  Just yesterday I realized I can
just clone a Git repo of the Gist and that's that.  I was thinking that the .zip
file download was the only way to go, but it isn't.  I knew about the Git repo
stuff, I just never even registered it as an option.</p>
<p>Kinda short post, but just wanted to share that.</p>
]]></description><link>http://blog.greduan.com/2014-08-09-ksbnri.html</link><guid isPermaLink="true">http://blog.greduan.com/2014-08-09-ksbnri.html</guid><dc:creator><![CDATA[Eduardo Lavaque]]></dc:creator><pubDate>Sat, 09 Aug 2014 00:00:00 GMT</pubDate></item><item><title><![CDATA[A week with Emacs]]></title><description><![CDATA[<p>I have begun writing this in the 5th day of my one week with Emacs.  Since a
friend of mine was making the switch to Emacs, or at least seriously attempting
I decided to take a challenge with him where we would only use Emacs.</p>
<p>The agreement was I would only use Emacs, for everything, with or without Evil
mode.  While he would use Emacs for anything that wasn't coding, as using Emacs
would be a serious dent to his prductivity and he basically wouldn't be
productive for a whole week.</p>
<p>We agreed to keep a journal of our experience with Emacs.  I haven't read his so
I'm not sure how detailed he is with his, or how dedicated, but I don't think
mine will be as detailed as his, in any case.</p>
<p>So I decided to share my experience in my blog and sharing my journal in it,
along with a more detailed version of the journal I suppose.</p>
<p>I put the whole journal in a file named <code>emacs-journal.txt</code> in my home
directory.  I won't pose the whole thing here, since it would just be a screen
hog, so I'll put it in a Gist, here it can be found:
<a href="https://gist.github.com/greduan/2f555993c1a537d8e7a5">https://gist.github.com/greduan/2f555993c1a537d8e7a5</a></p>
<p>After you read that, come back here for a more detailed version, or just skip
the journal altogether if that's what you prefer.</p>
<p>Be warned, if you came here for a review or a workflow blog post you may not
find what you are looking for here.  I say &quot;may&quot; because I am just now writing
this post and I don't know what'll come out of it.</p>
<p>In this post I think I will mainly share differences I have noted between
Emacs and Vim, its users, the workflows found in both, how the experience was
for me, a 1-2 year only-Vim user, etc.</p>
<p>Let us begin!</p>
<h2>Why Emacs?</h2>
<p>So a Vim user that can fluently think in motions and text objects, why the hell
would he want to be a traitor and switch to Emacs?</p>
<p>Well one, as I said earlier, it was a challenge in order to help my friend
switch to Emacs so that he wouldn't be alone and all of that, because being
the only one that uses a certain tool is kinda sad, I should know, I'm the only
one in my team that uses Vim, everyone else uses some IDE like PhpStorm (yuck!).
Also one of the two that uses Linux as the OS instead of OS X.</p>
<p>Two, I am naturally interested in Emacs, seeing how I am the user of the
archrival editor.</p>
<p>I also recently found <a href="http://input.fontbureau.com/">this font package</a>, but I can't really use it very
effectively in Vim so I thought I'd check out Emacs.  For the record I haven't
done anything with this yet.</p>
<p>OK let's get to the meat of this blog post.</p>
<h2>My observations</h2>
<p>About what?  Everything.</p>
<h3>The users</h3>
<p>The most glaring observation for me is the different kinds of users that use
Emacs and Vim.  Let me explain.</p>
<p>I feel like in Vim the user makes the changes fast, while in Emacs the user
takes a bit of time in order to code some kind of solution for Emacs to do it
for him.  In Emacs that piece of code forever remains in your <code>init.el</code> file
if you want and you can use it whenever, while in Vim if you want to make the
change again you just do the motion of keystrokes again, or record a macro and
save that somewhere.</p>
<p>Note: Do remember that I've only seriously used Emacs for 5 days at this point,
so I definitely don't know the workflow of a 10 year Emacs user.</p>
<p>In Emacs you can customize I think pretty much literally anything.  I don't mean
the figurative literally BTW, I mean the literal literally.</p>
<p>In Vim you can customize to a great extent your text editing experience, but you
can only customize your environment experience to the limits imposed by Vim's
options and settings.  Of course you can probably get very clever and do some
very interesting stuff to customize Vim.</p>
<p>[Note: Now the next day, the 6th day.]</p>
<p>So the users have very dfferent mindsets.  While in Emacs it is &quot;how can I
automate this?&quot; in Vim it's &quot;how many keystrokes can I find a way to skip?&quot;.
This is brought about by the differences between Emacs and Vim, IMO.</p>
<h3>The ergonomics</h3>
<p>I'm just going to go ahead and say it.  In my opinion, Emacs' default
keybindings <strong>suck</strong>.  Being a Vim user I found it super uncomfortable to have
to go and find the Ctrl and Alt keys constantly.  Maybe it has to do with how I
press the keys, maybe not, I press Ctrl using my left pinky and Alt using my
left thumb.  I don't feel like those keys are very strange but maybe they are.</p>
<p>And no, I did not switch Caps lock and Ctrl, neither will I do it.  I think I
tried doing it at some point for Tmux, as I heard suggestions to do that, and
remap the prefix to <code>Ctrl-a</code>.  I did not like it, felt unnatural.</p>
<p>Instead I decided to use something like <a href="https://github.com/chrisdone/god-mode">God-mode</a>, which feels like less of
a hack, however I haven't gotten used to using it every time I can so I haven't
gotten much benefit from it yet.</p>
<p>So yes.  Ergonomics.  Freakin' work on them please, at least make the keys more
natural.  <code>M-b</code> is exceptionally unnatural to press when you use your thumb to
press Alt, again that may be my own fault though.</p>
<h3>The damn tabs</h3>
<p>Why is it SO HARD to configure how tabs work?</p>
<p>I had tabs sorta figured out, just make everything be a hard tab and you'll be
fine, but that doesn't work when you're working with Lisp, because Lisp and
hard tabs are the bane of good code formatting.  But IMO tabs work everywhere
else better than spaces.</p>
<p>I'm not going to go through what I've tried, it wasn't a pleasant experience.
In Vim it's not pleasant either but at least it's straightforward.</p>
<p><strong>Notice from 2015: I <a href="http://blog.greduan.com/2015-04-29-iahie.html">figured it out</a>. :3</strong></p>
<h3>Elisp</h3>
<p>Elisp is cool.  Configuring an entire editor with it is a concept I enjoy
thinking about.</p>
<p>While Emacs is a HUGE piece of software, compared to Vim that is, it has a TON
of code, Elisp and C code, all to give you a great piece of software that you
can configure as much as you want without a second thought.</p>
<h3>Light Table is not the next Emacs</h3>
<p>This is a reference to a post I did previously, I was very excited about Light
Table and ClojureScript and all that jazz back then and I didn't really know all
that much about Emacs except what I had heard about it.</p>
<p>Yeah, Light Table is not the next Emacs, not even remotely close, it doesn't
even work inside the CLI so that already makes it very different. lol</p>
<h3>The package management</h3>
<p>I won't write a lot about it, I just want to say it's not an ideal situation.</p>
<p>There is already a <a href="http://batsov.com/articles/2012/02/19/package-management-in-emacs-the-good-the-bad-and-the-ugly/">really great post about this subject</a>.</p>
<p><strong>Notice from 2015: I am informed that that blog post is now very out of date,
and I myself can confirm.</strong></p>
<p>I have spent time with both <code>package.el</code> and El-get, I personally prefer
El-get so far, but <code>package.el</code> is still really great.</p>
<h2>Afterthought</h2>
<p>This blog post probably doesn't have a lot of flow, maybe.  It was written over
several days and it was basically just a rant, i.e. &quot;say whatever you have on
your mind&quot;.</p>
<p>I think it's quite noticeably I quickly ran out of stuff to say. lol</p>
<p>Oh yeah, there was no Evil-mode mentioned huh?</p>
<p>Also, since the 6th day I started using Vim for coding again, becaues Emacs was
too slow.</p>
]]></description><link>http://blog.greduan.com/2014-08-08-awwe.html</link><guid isPermaLink="true">http://blog.greduan.com/2014-08-08-awwe.html</guid><dc:creator><![CDATA[Eduardo Lavaque]]></dc:creator><pubDate>Fri, 08 Aug 2014 00:00:00 GMT</pubDate></item><item><title><![CDATA[A small project is not the same as a big project]]></title><description><![CDATA[<p>That's quite an obvious statement isn't it?  The one in the title.  Well I
didn't learn this until recently.</p>
<p>Let me explain myself, and how I'm not dumb.</p>
<p>A small project you can get a skeleton for in like an hour, you spend a bit of
time brainstorming features and how you can simplify it and in an hour you have
a skeleton, in 15 mins you have a project ready to start working on, you've
figured out the README the license etc., you just have to start making it now,
and that takes like 3 hours or less if you're good, depends on the project of
course.</p>
<p>In comparison, a big project you don't plan out quite as much, since that's
a bad idea to do at the start, instead you setup some tests (if you work Agile),
you make some decisions on what to start with etc.</p>
<p>After 5 hours, you're not nearly done with the big project, while the small
project you're at least halfway there if not done already.</p>
<p>If you're used to small projects, like I am, a bigger or slightly bigger project
may make you feel slow, at least it made me feel slow.</p>
<p>I just kinda want to say that's probably normal and not something to worry
about, if you haven't finished your idea in 6 months, maybe start worrying. lol</p>
]]></description><link>http://blog.greduan.com/2014-07-20-aspintsaabp.html</link><guid isPermaLink="true">http://blog.greduan.com/2014-07-20-aspintsaabp.html</guid><dc:creator><![CDATA[Eduardo Lavaque]]></dc:creator><pubDate>Sun, 20 Jul 2014 00:00:00 GMT</pubDate></item><item><title><![CDATA[A projects page!]]></title><description><![CDATA[<p><strong>Notice from 2015: Whilst I am not using this page anymore, it is still
available and this blog post is still here for historical purposes.  This post
is in the &quot;delete whenever&quot; list.</strong></p>
<p>Yay I made another part of my website! :D</p>
<p>Just thought at some point something like this might come in handy so I made
this website.</p>
<p>Can be found here: <a href="http://projects.greduan.com">http://projects.greduan.com</a></p>
<p>It is also found in the list of links in my home page.</p>
<p>It doesn't have all of my projects, as you may notice, but it is a list of those
that I personally think would benefit others and that are standalone from
another application, like DocPad or MetalSmith.</p>
<p>Of course this list may change and also the requirements that I have for me to
put them on there, but we'll see...</p>
]]></description><link>http://blog.greduan.com/2014-07-14-app.html</link><guid isPermaLink="true">http://blog.greduan.com/2014-07-14-app.html</guid><dc:creator><![CDATA[Eduardo Lavaque]]></dc:creator><pubDate>Mon, 14 Jul 2014 00:00:00 GMT</pubDate></item><item><title><![CDATA[Several VLC interfaces]]></title><description><![CDATA[<p>A couple of days ago I found out that VLC has several interfaces besides the
usual nice GUI interface.</p>
<p>In Arch Linux installing VLC also installs a couple of CLI interfaces for you.</p>
<p>For example it installs <code>nvlc</code>, which is an ncurses interface, which means you
don't need X11 to listen to that music or podcast or whatever.</p>
<p>It offers <code>cvlc</code>, which I don't know what it stands for but it allows you to
watch a video without the fancy GUI. So you do need X11 running but it doesn't
load the GUI and all that, just the video player and with some hotkeys I
imagine, when I pressed the spacebar it paused so maybe the rest work.</p>
<p>And of course it offers <code>vlc</code> which loads the normal VLC but you can give it a
path to the file or folder from the CLI.</p>
]]></description><link>http://blog.greduan.com/2014-06-19-svi.html</link><guid isPermaLink="true">http://blog.greduan.com/2014-06-19-svi.html</guid><dc:creator><![CDATA[Eduardo Lavaque]]></dc:creator><pubDate>Thu, 19 Jun 2014 00:00:00 GMT</pubDate></item></channel></rss>